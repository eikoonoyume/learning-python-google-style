# Reading Data Interactively
# interact with user to get info
# input function: allows us to prompt user for certain value to use in scripts
# example script = hello.py
cat hello.py
#!/usr/bin/env python3

name = input("Please enter your name: ")
print("Hello, " + name)

./hello.py
Please enter your name: Roger
# output: Hello, Roger
# input function always returns string
# convert string to format that reads numbers or dates
# define function that converts hours, minutes, seconds into seconds
def to_seconds(house, minutes, seconds):
  return hours*3600+minutes*60+seconds
# program starts with a welcome message
print("Welcome to this time converter")

# enter while loop after initializing cont variable
cont = "y"
while(cont.lower() == "y"):
# ask user to provide numbers, converting value using int function
  hours = int(input("Enter the number of hours: "))
  minutes = int(input("Enter the number of minutes: "))
  seconds = int(input("Enter the number of seconds: "))
  print("That's {} seconds".format(to_seconds(hours, minutes, seconds))
  print()
  cont = input("Do you want to do another conversion? [y to continue] ")
print("Goodbye!")
# resulting script
./seconds.py
Welcome to this time converter
Enter the number of hours: 1
Enter the number of minutes: 2
Enter the number of seconds: 3
# output: That's 3723 seconds

Do you want to do another conversion? [y to continue] y
Enter the number of hours: 3
Enter the number of minutes: 2
Enter the number of seconds: 1
# output: That's 10921 seconds

Do you want to do another conversion? [y to continue] n
# output: Goodbye!

# Standard Streams
# I/O streams = input output streams = pathways between programs and input sources (keyboard) and output (screen)
# STDIN = standard input stream, channel between program and input in form of text data from keyboard
# STDOUT = standard output stream, pathway between program and target/output like display
# STDOUT = form of text displayed in TERMINAL
# STDERR = standard error, displays output like STDOUT
# STDERR = specifically used to show error messages and program diagnostics, printed to screen
cat streams.py
#!/usr/bin/env python3
data = input("This will come from STDIN: ")
print("Now we write it to STDOUT: " + data)
print("Now we generate an error to STDERR: " + data + 1)
# error generated by concatenating string to an integer

./streams.py
This will come from STDIN: Python Rocks!
Now we write it to STDOUT: Python Rocks!
** Error message appears here **

# cat system command displays contents, printed to terminal using STDOUT
cat greeting.txt
Well hello there, STDOUT

# unsupported flag with ls system generates an error
cat greeting.txt
Well hello there, STDOUT

ls -z
** Invalid option message appears **

# Environment Variables
# shell = application that reads and executes our commands, command-line interface that interacts with OS
# bash = most commonly used shell on Linux
# Zsh and Fish are popular shells
# environment variables = another source of info for scripts
# use env or env command to check variables
# path variable = important
# echo command = prints contents in Linux shell
# access value of variable by putting a dollar sign $ prefix on the name of varaible
echo $PATH
# contents of path variable, directories listed
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
cat variables.py
#!/usr/bin/env python3
import os
print("HOME: " + os.environ.get("HOME", ""))
# environ dictionary from OS module, using dictionary method
# GET method is similar to access dictionary values
print("SHELL: " + os.environ.get("SHELL", ""))
print("FRUIT: " + os.environ.get("FRUIT", ""))
# when value isn't present, retrieve value from dictionary using os.environ[FRUIT]
# if key isn't present, then error
# use GET method instead to sepcify what value should be returned if key isn't present
./variables.py
# output: HOME: /home/user
# output: SHELL: /bin/bash
# output: FRUIT:
export FRUIT=Pineapple
# define variable by setting value using equal sign and NO SPACES IN BETWEEN

./variables.py
# output: HOME: /home/user
# output: SHELL: /bin/bash
# output: FRUIT: Pineapple

# Command-Line Arguments and Exit Status
# provide info to programs through command-line arguments
# as parameters passed to program
# no need for interactive user input
# useful for system administration tasks
# specify info we want to use before starting to create more automation
# argv in sys module = access values of argument
cat parameters.py
#!/usr/bin/env python3
import sys
print(sys.argv)

./parameters.py
['./parameters.py']
# single element

# pass more parameters
./parameters.py one two three
['./parameters.py', 'one', 'two', 'there']

# Exit Status
# exit status/return code = provides another source of info between shell and programs
# value returned to program by shell
# exit status = 0 when process succeeds, not 0 if fails
# actual number gives info on what kind of error
# check the exit status, use special variable to see exit status of last executed command
# WC command = counts the number of lines, words, and characters in a file
# pass variables.py script
wc variables.py
7 19 174 variables.py
echo $?
0

wc notpresent.sh
wc: notpresent.sh: No such file or directory
echo $?
1

#!/usr/bin/env python3
import os
import sys

filename = sys.argv[1]
if not os.path.exists(filename):
# when file doesn't exist, create it by writing a line to it
  with open(filename, "w") as f:
    f.write("New file created\n")
else:
# when file exists, print error message and exit with value of 1
  print("Error, the file {} already exists!".format(filename))
  sys.exit(1)
  
# pass nonexistent file  
./create_file.py example
echo $?
0
# check contents
cat example
New file created
# run command again
./create_file.py example
Error, the file example already exists!
echo $?
1
# error because file already exists

# Input Functions
# Python 2 vs Python 3
# Python 2, using raw_input() to input from user
>>> my_number = raw_input('Please Enter a Number: \m')
Please Enter a Number:
1337
>>> print(my_number)
1337

# raw_input does not evaluate, just gets string from user
>>> my_raw_input = raw_input('Please Enter a Number: \n')
Please Enter a Number:
123 + 1 # treated like a raw string
>>> my_input = input('Please Enter a Number: \n')
Please Enter a Number:
123 + 1 # treated like an expression
>>> print(my_raw_input)
123 + 1
>>> print(my_input)
124 # expression was evaluated and math happened!

# Python 3, using input()
>>> my_number = input('Please Enter a Number: \n')
Please Enter a Number:
123 + 1
>>> print(my_number)
123 + 1
>>> eval(my_number)
124
# raw_input() = not in Python 3 but there are ways
# eval() = evaluates string expressions

# Running System Commands in Python
# Review: file objects to read file contents
# Review: shutil module = check of disk is full
# Review: sys module to process STDIN, get parameters, generate exit code
# ping command = send packets
# Python: using subprocess module to get functions that will execute system commands
# Send ICMP packets to host to check if it's responding
# child process = subprocess
# parent process = script
# child process creates a secondary environment to execute command, parent process waits and is blocked until child process finishes
# import subprocess module
import subprocess
# call date command = shows current date using subprocess.run function
subprocess.run(["date"])
# output: 
# Tue 07 Jan 2020 02:34:44 PM PST
# CompletedProcess(args=[‘date’], returncode=0)
# CompletedProcess type object was returned, return code was 0
# sleep command = waits for number of seconds that we tell it before returning
subprocess.run(["sleep", "2"])
# output: CompletedProcess(args=[‘sleep’, ‘2’], returncode=0)
# interpreter was blocked, run function receives list that startes with name of command and then parameter
# requesting sleep to wait for two seconds

# when exit status is not 0
# call LS with file name that doesn't exist
# prints error and returns an exit status that is not 0
# stored in return code attribute of CompletedProcess instance
result = subprocess.run(["ls", "this_file_does_not_exist"])
# output: ls: cannot access ‘this_file_does_not_exist’: No such file or directory
print(result.returncode)
# output: 2

# Obtaining Output of System Command
# tell run function to capture the output so it can be manipulted by scripts
# helpful when we need to extract info from command and use it for something else
# who command = prints users currently logged into a computer
# parse output, store list of logged-in users once per hour, generate a daily report at end of the date
# set parameter called capture output to True when calling run function to process output of commands
# call host command = convert a host name to an IP address and vice versa
# pass capture output = True parameter, store result in variable to be accessible
result = subprocess.run(["host", "8.8.8.8"], capture_output=True)
print(result.returncode)
# output: 0
# print and operate which was generated by the command and stored in the STDOUT attribute
result = subprocess.run(["host", "8.8.8.8"], capture_output=True)
print(result.stdout)
# output: B’8.8.8.8. In-addr.arpa domain name pointer dns.google.in’
# B = tells us this string is not a proper string for Python, it's just an array of bytes
# data in computers = stored and transmitted in bytes, can represent up to 256 characters
# most people use UTF-8 encoding (part of Unicode standard that lists all possible characters that can be represented)
# we need to change to proper string, call decode method = applies an encoding to transform the bytes into string
print(result.stdout.decode().split())
# output: [‘8.8.8.8. In-addr.arpa’, ‘domain’, ‘name’, ‘pointer’, ‘dns.google.’]
# execute rm command = removes files passing a filename that doesn't exist
import subprocess
result = subprocess.run(["rm", "does_not_exist"], capture_output=True
print(result.returncode)
# output: 1
# check contents of STDOUT and STDERR attributes
print(result.stdout)
# output: b''
print(result.stderr)
# output: b”rm: cannot remove ‘does_not_exist’: No such file or directory\n”

# Advanced Subprocess Management
# modify environment variables
# change where the process looks for executable files, which commands are used to interact with system, kind of output generated, etc
# call copy method of OS environ dictioary which contains current environment variables
# create a new dictionary that we can change without modifying original environment
import os
import subprocess

my_env = os.environ.copy()
my_env["PATH"] = os.pathsep.join(["/opt/myapp/", my_env["PATH"]])
# call join method on OS path substring to create new value
# joining /opt/myapp and old value of path variable to path separator
# call myapp command = set end of parameter to new environment just prepared
result = subprocess.run(["myapp"], env=my_env)

# More options to use with run function
# CWD parameter = change the current working dictionary
# set timeout parameter = cause run function to kill process if it takes longer than given number of seconds to finish
# shell parameter = True = Python will first execute an instance of default system shell, then run given command inside

# using system commands and subprocesses is helpful for automating a one-off, well-defined task for developing quick solution
# using baked-in or external modules from Python is better for complex or long-running tasks
# don't reinvent the wheel: check if Python can do it, or if someone already created an automation

# Filtering Log Files with Regex
# open function = returns file object, then iterates through each line using for-loop
#!/bin/env/python3

import sys
logfile = sys.argv[1]
with open(logfile) as f:
  for line in f:
    print(line.strip())
# read line by line if file is large
# CRON jobs = schedule scripts on UNIX-based OS
# audit log files and see who's been launching CRON jobs
# ignore any line without CRON substring, check using "in" keyword
#!/bin/env/python3
import sys
logfile = sys.argv[1]
with open(logfile) as f:
  for line in f:
    if "CRON" not in line:
      continue
    print(line.strip())
# continue keyword = tells loop to go to next element

# extract usernames using regex
# use escape characters, capture groups, end of string anchor
# username foundat end log line, use $ sign anchor to only match texts at end of line
# username = "user" followed by a string wrapped in parentheses
# escape parenthesis with backslash
# use another set of parenthesis to create capture group
# username = match any alphanumeric character by using backslash w plus
import re
pattern = r"USER \((\w+)\)$"
line = "Jul 6 14:03:01 computer.name CRON[29440]: USER (naughty_user)"
result = re.search(pattern, line)
print(result[1]_
# add to script
#!/bin/env/python3

import re
import sys

logfile = sys.argv[1]
with open(logfile) as f:
  for line in f:
    if "CRON" not in line:
      continue
    pattern = r"USER \((\w+)\)$"
    result = re.search(pattern, line)
    print(result[1])
# run it
chmod +x check_cron.py
./check_cron.py syslog
# output:
# good_user
# naughty_user
# naughty_user
# naughty_user

# use same syslog, display date, time, process ID inside square brackets
# read each line of syslog, pass contents to show_time_of_pid function
# extract date, time, process ID, return format: Jul 6 14:01:23 pid:29440
import re
def show_time_of_pid(line):
  pattern = r"(^\w* .\d*.\d*:\d*:\d+)(.*)\[(\d+)\]"
  result = re.search(pattern, line)
  return "{} pid:{}".format(result.group(1), result.group(3))
print(show_time_of_pid("Jul 6 14:01:23 computer.name CRON[29440]: USER (good_user)"))
print(show_time_of_pid("Jul 6 14:02:08 computer.name jam_tag=psim[29187]: (UUID:006)"))
print(show_time_of_pid("Jul 6 14:02:09 computer.name jam_tag=psim[29187]: (UUID:007)"))
print(show_time_of_pid("Jul 6 14:03:01 computer.name CRON[29440]: USER (naughty_user)"))
print(show_time_of_pid("Jul 6 14:03:40 computer.name cacheclient[29807]: start syncing from \"0xDEADBEEF\""))
print(show_time_of_pid("Jul 6 14:04:01 computer.name CRON[29440]: USER (naughty_user)"))
print(show_time_of_pid("Jul 6 14:05:01 computer.name CRON[29440]: USER (naughty_user)"))
# output:
# Jul 6 14:01:23 pid:29440
# Jul 6 14:02:08 pid:29187
# Jul 6 14:02:09 pid:29187
# Jul 6 14:03:01 pid:29440
# Jul 6 14:03:40 pid:29807
# Jul 6 14:04:01 pid:29440
# Jul 6 14:05:01 pid:29440

# Making Sense out of the Data
# dictionaries = useful when wanting to count appearances of strings
# store username as keys, use value to count nmber of appearances
# create an empty dictionary using curly brackets
usernames = {}
# set variable name as good_user for example
name = "good_user"
# set value associated with key as one more than current value
usernames[name] = usernames.get(name, 0) +1
# get method = get current value
# current value = default value of zero, key that is present = default value
# add one to value and set as new value
print(usernames)
# output: {'good_user': 1}
usernames[name] = usernames.get(name, 0) +1
print(usernames)
# output: {'good_user': 2}

# initialize empty dictionary at beginning of code
#!/bin/env/python3

import re
import sys

logfile = sys.argv[1]
usernames = {}
# check that we actually match regex, check if result variable is none
with open(logfile) as f:
  for line in f:
    if "CRON" not in line:
      continue
# use continue keyword if result is none
    pattern = r"USER \((\\w+)\)$"
    result = re.search(pattern, line)
# add values to dictionary as we process
    if result is None:
      continue
    name = result[1]
# define name variable that will store capture group
    usernames[name] = usernames.get(name, 0) +1
# print results in dictionary
print(usernames)
# try test file
./check_cron.py syslog
# output: {'good_user':1, 'naughty_user':3}

# Qwiklabs: Word with Log Files
# write script to search log file for exact error, output that error into separate file to work out what's wrong
# fishy.log log entry format: Month Day hour:minute:second mycomputername "process_name"["random 5 digit number"] "ERROR/INFO/WARN" "Error description"
# view all logs with cat comamand
cat ~/data/fishy.log
# use Python to search log files for ERROR log
# narrow search to "CRON ERROR Failed to start"
# create python script named find_error.py in scripts directory using nano editor
cd ~/scripts
nano find_error.py
# add shebang line
#!/usr/bin/env/python3
import sys
import os
import re
# sys module = info about Python interpreter's constants, functions, methods
# os module = provides portable way of using OS dependent functionarity with Python
# regex = sequnce of characters that define a search pattern, use re module
# write function error_search that takes log_file as parameter, turns returned_errors
# define error_search and pass log file as parameter
def error_search(log_file):
# search all logs for any type of logs, make scrip consistent and dynamic
# define input function to receive the type of ERROR that the end-user would like to search
# assign to variable named error
# input() function takes input from user and evaluates the expression
# Python autoomatically identifies whether the user entered a string, number, or list
# incorrect input leads to syntax error or exception(stop, until user gives input)
# iterate over user input and log files
# intialize list called returne_errors
error = input("What is the error?")
  returned_erros = []
# use Python methods for file handling
# open log file in reading mode, ues UTF-8 encoding
with open(log_file, mode='r', encoding='UTF-8') as file:
# read each log separately from fishy.log using readlines() method
# iterate over user input to get desired search results
# create a list to store all patterns(user input)
# list named error_patterns
# error_patterns has a pattern "error" to filter out all ERROR logs only
# change this to view other types of logs like INFO and WARN
# empty initialize the list to fetch all types of logs
# ad whole user input to this list called error_patterns
  for log in file.readlines():
    error_patterns = ["error"]
    for i in range(len(error.split(' '))):
      error_patterns.append(r"{}".format(error.split(' ')[i].lower()))
# use search() method from re module = check whether fishy.log file has user defined pattern
# check if it's available, append to list called returned_errors
    if all(re.search(error_pattern, log.lower()) for error_pattern in error_patterns):
      returned_errors.append(log)
  file.close()
return returned_errors
# define file_output() function = takes returned_errors as formal parameter
def file_output(returned_errors):
# write returned_errors into errors_found.log file by opening file in writing mode
# use method os.path.expanduser ('~') to define output file, return home directory of system instance
# concatenate path (to the home directory) to file errors_found.log in /data directory
  with open(os.path.expanduser('~') + '/data/errors_found.log', 'w') as file:
# write all logs to output file by iterating over returned_errors
    for error in returned_errors:
      file.write(error)
    file.close()
# call functions, run script
# define main function, call both functions defined earlier
# variable log_file takes in path to log file passed as parameter
# call first function (error_search()) and pass variable log_file to function
# return list of errors that would be stored in variable returned_errors
# call second function (file_output()) and pass variable returned_errors as parameter
# sys.exit(0) = exit from Python
# optional argument passed can be integer giving the exit status (defaulting to zero) or another type of object
# integer zero = "successful termination", nonzero value = "abnormal termination" by shells
if __name__ == "__main__":
  log_file = sys.argv[1]
  returned_errors = error_search(log_file)
  file_output(returned_errors)
  sys.exit(0)
# ctrl-o, Enter, ctrl-x to save
# make file executable before running
sudo chmod +x find_error.py
# run by passing path to fishy.log as parameter
./find_error.py ~/data/fishy.log
# enter type of error to be searched
CRON ERROR Failed to start
# generates errors_found.log 
# view ERROR log
cat ~/data/errors_found.log

