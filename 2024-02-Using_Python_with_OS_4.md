# Reading Data Interactively
# interact with user to get info
# input function: allows us to prompt user for certain value to use in scripts
# example script = hello.py
cat hello.py
#!/usr/bin/env python3

name = input("Please enter your name: ")
print("Hello, " + name)

./hello.py
Please enter your name: Roger
# output: Hello, Roger
# input function always returns string
# convert string to format that reads numbers or dates
# define function that converts hours, minutes, seconds into seconds
def to_seconds(house, minutes, seconds):
  return hours*3600+minutes*60+seconds
# program starts with a welcome message
print("Welcome to this time converter")

# enter while loop after initializing cont variable
cont = "y"
while(cont.lower() == "y"):
# ask user to provide numbers, converting value using int function
  hours = int(input("Enter the number of hours: "))
  minutes = int(input("Enter the number of minutes: "))
  seconds = int(input("Enter the number of seconds: "))
  print("That's {} seconds".format(to_seconds(hours, minutes, seconds))
  print()
  cont = input("Do you want to do another conversion? [y to continue] ")
print("Goodbye!")
# resulting script
./seconds.py
Welcome to this time converter
Enter the number of hours: 1
Enter the number of minutes: 2
Enter the number of seconds: 3
# output: That's 3723 seconds

Do you want to do another conversion? [y to continue] y
Enter the number of hours: 3
Enter the number of minutes: 2
Enter the number of seconds: 1
# output: That's 10921 seconds

Do you want to do another conversion? [y to continue] n
# output: Goodbye!

# Standard Streams
# I/O streams = input output streams = pathways between programs and input sources (keyboard) and output (screen)
# STDIN = standard input stream, channel between program and input in form of text data from keyboard
# STDOUT = standard output stream, pathway between program and target/output like display
# STDOUT = form of text displayed in TERMINAL
# STDERR = standard error, displays output like STDOUT
# STDERR = specifically used to show error messages and program diagnostics, printed to screen
cat streams.py
#!/usr/bin/env python3
data = input("This will come from STDIN: ")
print("Now we write it to STDOUT: " + data)
print("Now we generate an error to STDERR: " + data + 1)
# error generated by concatenating string to an integer

./streams.py
This will come from STDIN: Python Rocks!
Now we write it to STDOUT: Python Rocks!
** Error message appears here **

# cat system command displays contents, printed to terminal using STDOUT
cat greeting.txt
Well hello there, STDOUT

# unsupported flag with ls system generates an error
cat greeting.txt
Well hello there, STDOUT

ls -z
** Invalid option message appears **

# Environment Variables
# shell = application that reads and executes our commands, command-line interface that interacts with OS
# bash = most commonly used shell on Linux
# Zsh and Fish are popular shells
# environment variables = another source of info for scripts
# use env or env command to check variables
# path variable = important
# echo command = prints contents in Linux shell
# access value of variable by putting a dollar sign $ prefix on the name of varaible
echo $PATH
# contents of path variable, directories listed
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
cat variables.py
#!/usr/bin/env python3
import os
print("HOME: " + os.environ.get("HOME", ""))
# environ dictionary from OS module, using dictionary method
# GET method is similar to access dictionary values
print("SHELL: " + os.environ.get("SHELL", ""))
print("FRUIT: " + os.environ.get("FRUIT", ""))
# when value isn't present, retrieve value from dictionary using os.environ[FRUIT]
# if key isn't present, then error
# use GET method instead to sepcify what value should be returned if key isn't present
./variables.py
# output: HOME: /home/user
# output: SHELL: /bin/bash
# output: FRUIT:
export FRUIT=Pineapple
# define variable by setting value using equal sign and NO SPACES IN BETWEEN

./variables.py
# output: HOME: /home/user
# output: SHELL: /bin/bash
# output: FRUIT: Pineapple

# Command-Line Arguments and Exit Status
# provide info to programs through command-line arguments
# as parameters passed to program
# no need for interactive user input
# useful for system administration tasks
# specify info we want to use before starting to create more automation
# argv in sys module = access values of argument
cat parameters.py
#!/usr/bin/env python3
import sys
print(sys.argv)

./parameters.py
['./parameters.py']
# single element

# pass more parameters
./parameters.py one two three
['./parameters.py', 'one', 'two', 'there']

# Exit Status
# exit status/return code = provides another source of info between shell and programs
# value returned to program by shell
# exit status = 0 when process succeeds, not 0 if fails
# actual number gives info on what kind of error
# check the exit status, use special variable to see exit status of last executed command
# WC command = counts the number of lines, words, and characters in a file
# pass variables.py script
wc variables.py
7 19 174 variables.py
echo $?
0

wc notpresent.sh
wc: notpresent.sh: No such file or directory
echo $?
1

#!/usr/bin/env python3
import os
import sys

filename = sys.argv[1]
if not os.path.exists(filename):
# when file doesn't exist, create it by writing a line to it
  with open(filename, "w") as f:
    f.write("New file created\n")
else:
# when file exists, print error message and exit with value of 1
  print("Error, the file {} already exists!".format(filename))
  sys.exit(1)
  
# pass nonexistent file  
./create_file.py example
echo $?
0
# check contents
cat example
New file created
# run command again
./create_file.py example
Error, the file example already exists!
echo $?
1
# error because file already exists

# Input Functions
# Python 2 vs Python 3
# Python 2, using raw_input() to input from user
>>> my_number = raw_input('Please Enter a Number: \m')
Please Enter a Number:
1337
>>> print(my_number)
1337

# raw_input does not evaluate, just gets string from user
>>> my_raw_input = raw_input('Please Enter a Number: \n')
Please Enter a Number:
123 + 1 # treated like a raw string
>>> my_input = input('Please Enter a Number: \n')
Please Enter a Number:
123 + 1 # treated like an expression
>>> print(my_raw_input)
123 + 1
>>> print(my_input)
124 # expression was evaluated and math happened!

# Python 3, using input()
>>> my_number = input('Please Enter a Number: \n')
Please Enter a Number:
123 + 1
>>> print(my_number)
123 + 1
>>> eval(my_number)
124
# raw_input() = not in Python 3 but there are ways
# eval() = evaluates string expressions

# Running System Commands in Python
# Review: file objects to read file contents
# Review: shutil module = check of disk is full
# Review: sys module to process STDIN, get parameters, generate exit code
# ping command = send packets
# Python: using subprocess module to get functions that will execute system commands
# Send ICMP packets to host to check if it's responding
# child process = subprocess
# parent process = script
# child process creates a secondary environment to execute command, parent process waits and is blocked until child process finishes
# import subprocess module
import subprocess
# call date command = shows current date using subprocess.run function
subprocess.run(["date"])
# output: 
# Tue 07 Jan 2020 02:34:44 PM PST
# CompletedProcess(args=[‘date’], returncode=0)
# CompletedProcess type object was returned, return code was 0
# sleep command = waits for number of seconds that we tell it before returning
subprocess.run(["sleep", "2"])
# output: CompletedProcess(args=[‘sleep’, ‘2’], returncode=0)
# interpreter was blocked, run function receives list that startes with name of command and then parameter
# requesting sleep to wait for two seconds

# when exit status is not 0
# call LS with file name that doesn't exist
# prints error and returns an exit status that is not 0
# stored in return code attribute of CompletedProcess instance
result = subprocess.run(["ls", "this_file_does_not_exist"])
# output: ls: cannot access ‘this_file_does_not_exist’: No such file or directory
print(result.returncode)
# output: 2

# Obtaining Output of System Command
# tell run function to capture the output so it can be manipulted by scripts
# helpful when we need to extract info from command and use it for something else
# who command = prints users currently logged into a computer
# parse output, store list of logged-in users once per hour, generate a daily report at end of the date
# set parameter called capture output to True when calling run function to process output of commands
# call host command = convert a host name to an IP address and vice versa
# pass capture output = True parameter, store result in variable to be accessible
result = subprocess.run(["host", "8.8.8.8"], capture_output=True)
print(result.returncode)
# output: 0
# print and operate which was generated by the command and stored in the STDOUT attribute
result = subprocess.run(["host", "8.8.8.8"], capture_output=True)
print(result.stdout)
# output: B’8.8.8.8. In-addr.arpa domain name pointer dns.google.in’
# B = tells us this string is not a proper string for Python, it's just an array of bytes
# data in computers = stored and transmitted in bytes, can represent up to 256 characters
# most people use UTF-8 encoding (part of Unicode standard that lists all possible characters that can be represented)
# we need to change to proper string, call decode method = applies an encoding to transform the bytes into string
print(result.stdout.decode().split())
# output: [‘8.8.8.8. In-addr.arpa’, ‘domain’, ‘name’, ‘pointer’, ‘dns.google.’]
# execute rm command = removes files passing a filename that doesn't exist
import subprocess
result = subprocess.run(["rm", "does_not_exist"], capture_output=True
print(result.returncode)
# output: 1
# check contents of STDOUT and STDERR attributes
print(result.stdout)
# output: b''
print(result.stderr)
# output: b”rm: cannot remove ‘does_not_exist’: No such file or directory\n”

# Advanced Subprocess Management
# modify environment variables
# change where the process looks for executable files, which commands are used to interact with system, kind of output generated, etc
# call copy method of OS environ dictioary which contains current environment variables
# create a new dictionary that we can change without modifying original environment
import os
import subprocess

my_env = os.environ.copy()
my_env["PATH"] = os.pathsep.join(["/opt/myapp/", my_env["PATH"]])
# call join method on OS path substring to create new value
# joining /opt/myapp and old value of path variable to path separator
# call myapp command = set end of parameter to new environment just prepared
result = subprocess.run(["myapp"], env=my_env)

# More options to use with run function
# CWD parameter = change the current working dictionary
# set timeout parameter = cause run function to kill process if it takes longer than given number of seconds to finish
# shell parameter = True = Python will first execute an instance of default system shell, then run given command inside

# using system commands and subprocesses is helpful for automating a one-off, well-defined task for developing quick solution
# using baked-in or external modules from Python is better for complex or long-running tasks
# don't reinvent the wheel: check if Python can do it, or if someone already created an automation

# Filtering Log Files with Regex

