# Strings
name = "Sasha"
color = 'Gold'
print("Name: " + name + ", Favorite color: " + color)
# output
# Name: Sasha, Favorite color: Gold

# Multiplying Strings
"example" * 3
# output
# exampleexampleexample

# len() function
pet = ""
pet = "loooooooooooooooooooooooooooooooog cat"
len(pet)
# output
# 38

# Index Positions
name = "Jaylen"
print(name[1])
# output
# a

# Slice/Substring
fruit = "Mangosteen"
fruit[1:4]
fruit[:5]
fruit[5:]
fruit{:5] + fruit[5:]
# output:
# ang
# Mango
# steen
# Mangosteen

# Create New Strings
message = "A kong string with a silly typo"
new_message = message[0:2] + "l" + message[3:]
print(new_message)
# output
# A long string with a silly typo

message = "This is a new message"
print(message)
# output
# This is a new message
message = "And another one"
print(message)
# output
# And another one

# Example
pets = "Cats & Dogs"
pets.index("&")
# output: 5
pets.index("C")
# output: 0
pets.index("Dog")
# output: 7
pets.index("s")
# output: 3 (only returns the first encounter)
pets="Cats & Dogs"
pets.index("x")
# output: Error
pets="Cats & Dogs"
"Dragons" in pets
# output: False
"Cats" in pets
# output: True

# Example
def replace_domain(email, old_domain, new_domain):
  if "@" + old_domain in email:
    index = email.index("@" + old_domain)
    new_email = email[:index] + "@" + new_domain
    return new_email
  return email

  # Example
  # Using the index method, find out the position of "x" in "supercalifragilisticexpialidocious".
  word = "supercalifragilisticexpialidocious"
  print(word.index("x")
  # output: 21

  # Capitalizing
  "Mountains".upper()
  # output: MOUNTAINS

  # Lower-case
  "Mountains".lower()
  # output: mountains

  # Deleting Spaces
  " yes ".strip()
  # output: 'yes'

  # Deleting space to left
  " yes ".lstrip()
  # output: 'yes '

  # Deleting space to right
  " yes ".rstrip()
  # output: ' yes'

  # Counting number of occurences
  "The number of times e occurs in this string is 4."count("e")
  # output: 4

  # Boolean for whether or not something ends with something
  "Forest".endswith("rest")
  # output: True

  # Boolen to check if something is made up of just numbers
  "Forest".isnumeric()
  # output: Flase
  "12345".isnumeric()
  # output: True

  # int() function to convert to a number
  int("12345") + int("54321")
  # output: 66666

  # Concatenate with +
  " ".join(["This", "is", "a", "phrase", "joined", "by", "spaces"])
  # output: This is a phrase joined by spaces

  "...".join(["This", "is", "a", "phrase", "joined", "by", "triple", "dots"])
  # output: This...is...a...phrase...joined...by...triple...dots

  # Split a list of strings
  "This is another example".split()
  # outout: ['This', 'is', 'another', 'example']

  # Example using format {}
  name = "Manny"
  number = len(name) * 3
  print("Hello {}, your lucky number is {}".format(name, number))
  # output: Hello Manny, your lucky number is 15

  # More Advanced Version, you can put things in the brackets
  name = "Manny"
  print("Your lucky number is {number}, {name}.".format(name=name, number=len(name)*3))
  # output: Your lucky number is 15, Manny.
  
  # Example
  # Modify the student_grade function using the format method, so that it returns the phrase "X received Y% on the exam". For example, student_grade("Reed", 80) should return "Reed received 80% on the exam".
  def student_grade(name, grade):
    return "{} received {}% on the exam".format(name, grade)
  print(student_grade("Reed", 80))
  print(student_grade("Paige", 92))
  print(student_grade("Jesse", 85))
  # output:
  # Reed received 80% on the exam
  # Paige received 92% on the exam
  # Jesse received 85% on the exam

  # Example
  price 7.5
  with_tax = price*1.09
  print(price, with_tax)
  # output
  # 7.5 8.175

  # Limit Decimals with {:.2f}
  price 7.5
  with_tax = price*1.09
  print("Base price: ${:.2f}. With Tax: ${:.2f}".format(price, with_tax)
  # output: Base price $7.50. With Tax: $8.18

  # Example Limiting Decimals 
  def to_celsius(x):
    return (x-32)*5/9
  for x in range(0,101,10):
    print("{:>3} F | {:>6.2f} C".format(x, to_celsius(x)))
  # output:
  # 0 F | -17.78 C
  # 10 F | -12.22 C
  # etc

  # {:>3} = align to the right for total of 3 spaces
  # {:>6.2f} = align to the right at 6 spaces, limit to exactly 2 decimal places

  # Example explaining limiting decimals
  basket = [
    ("Peaches", 3.0, 2.99),
    ("Pears", 5.0, 1.66),
    ("Plums", 2.5, 3.99)
  ]
  subtotal = 0.00
  for item in basket:
    fruit, weight, unit_price = item
    subtotal += (weight * unit_price)
  tax_rate = 0.06625 # 6.6235% sales tax in NJ
  tax_amt = subtotal * tax_rate
  total = subtotal + tax_amt

  print("Subtotal:", subtotal)
  print("Sales Tax:", tax_amt)
  print("Total:", total)
  # output:
  # Subtotal: 27.245
  # Sales Tax: 1.8049812500000002 
  # Total: 29.049981250000002
  # needs to be limited in decimal points
  # ":10" makes the output 10 characters wide.
  #  "," inserts thousands separators between groups of digits.
  #  ".2" limits the output to two digits after the decimal.
  #  "f" tells Python to expect a floating-point number.

  print("Subtotal:" ${:10,.2f}".format(subtotal))
  print("Sales Tax:" ${:10,.2f}".format(tax_amt))
  print("Total:" ${:10,.2f}".format(total))
  # output:
  # Subtotal:     $    27.25 
  # Sales Tax:    $     1.80 
  # Total:        $    29.05

  # Example
  fruit = "peaches"
  weight = 3.0
  per_pound = 2.99
  output = "You are buying {} pounds of {} at {} per pound.".format(weight, fruit, per_pound)
  print(output)
  # output:
  # You are buying 3.0 pounds of peaches at 2.99 per pound.

  # Example
  output = "{1} are {2} per pound, and you have {0} pounds of {1}.".format(weight, fruit, per_pound)
  print(output)
  # output:
  # Peaches are 2.99 per pound, and you have 3.0 pounds of peaches.

  # Example
  output = "{fruit} are {price} per pound, and you have {weight} pounds of {fruit}.".format(weight=weight, fruit=fruit, price=per_pound)
  print(output)
  # output:
  # Peaches are 2.99 per pound, and you have 3.0 pounds of peaches.

  # Example Checking to See if Each Character in the String is a Letter or Not. If yes, the letter is added to the end of "forwards" and the beginning of "backwards"
  def mirrored_string(my_string):
    forwards = "" # initialize
    backwards = "" # initialize
    for character in my_string: # loop iterates through the my_string
      if character.isalpha(): # checking to see if it's a space or not
        forwards += character
        backwards += character + backwards
    if forwards.lower() == backwards.lower(): # False = no action, loop resarts until my_string is done, if-statement checks to see if the letters are the same in forwards and backwards and will be converted to lower-case
      return True
    return False
   print(mirrored_string("12 Noon"))
   print(mirrored_string("Was it a car or cat I saw"))
   print(mirrored_string("'eve, Madam Eve"))
   # output:
   # True
   # False
   # True

  # Example
  def convert_weight(ounces):
   pounds = ounces/16
   result = "{} ounces equals {:.2f} pounds".format(ounces, pounds)
   return result
  print(convert_weight(12))
  print(convert_weight(50.5))
  print(convert_weight(16))
  # output:
  # 12 ounces equals 0.75 pounds
  # 50.5 ounces equals 3.16 pounds
  # 16 ounces equals 1.00 pounds

  # Example 
  def username(last_name, birth_year):
    return("{}{}".format(last_name[0:3],birth_year))
  print(username("Ivanov", "1985"))
  print(username("Rodriguez", "2000"))
  print(username("Deng", "1991"))
  # output:
  # Iva1985
  # Rod2000
  # Den1991

  # Example checks a given schedule entry for an old date and replaces it with a new one
  def replace_date(schedule, old_date, new_date):
    if schedule.endswith(old_date): # check if the old date appears at the end of schedule
      p = len(old_date) # True: the variable "p" is used to hold the slicing index position, len() used to measure the lenght of new_date string
      new_schedule = schedule[:-p] + schedule[-p:].replace(old_date, new_date) # new string holds the updated string, [:-p] trims old date starting at final index and counting left the same number that's in len(old_date). [-p:] starts the index position where the first character of "old_date" was positioned
      return new_schedule # returns new date
    return schedule # if the schedule didn't end with the old date in the first place then just return the original sentence
  print(replace_date("Last year's annual report will be released in Marchc 2023", "2023", "2024"))
  print(replace_date("In April, the CEO will hold a conference, "April", "May"))
  print(replace_date("The convension is scheduled for October", "October", "June"))
  # output:
  # Last year's annual report will be released in March 2024
  # In April, the CEo will hold a conference # no change
  # The convention is schedule for June

  # Example
  # Fill in the blanks to complete the is_palindrome function. This function checks if a given string is a palindrome. A palindrome is a string that contains the same letters in the same order, whether the word is read from left to right or right to left. Examples of palindromes are words like kayak and radar, and phrases like "Never Odd or Even". The function should ignore blank spaces and capitalization when checking if the given string is a palindrome. Complete this function to return True if the passed string is a palindrome, False if not. 
  def is_palindrome(input_string):
    new_string = ""
    reverse_string = ""
    for letter in input_string:
      if letter != " ":
        new_string += letter
        reverse_string = letter + reverse_string
    if new_string.lower() == reverse_string.lower():
      return True
    return False
  print(is_palindrome("Never Odd or Even"))
  print(is_palindrome("abc"))
  print(is_palindrome("kayak"))
  # output:
  # True
  # False
  # True

  # Example
  # Using the format method, fill in the gaps in the convert_distance function so that it returns the phrase "X miles equals Y km", with Y having only 1 decimal place. For example, convert_distance(12) should return "12 miles equals 19.2 km".
  def convert_distance(miles):
    km = miles*1.6
    result = "{} miles equals {:.1f} km".format(miles, km)
    return result
  print(convert_distance(12))
  print(convert_distance(5.5))
  print(convert_distance(11))
  # output:
  # 12 miles equals 19.2 km
  # 5.5 miles equals 8.8 km
  # 11 miles equals 17.6 km

  # Example
  # Fill in the gaps in the nametag function so that it uses the format method to return first_name and the first initial of last_name followed by a period. For example, nametag("Jane", "Smith") should return "Jane S."
  def nametag(first_name, last_name):
    return("{} {}.".format(first_name, last_name[:1]))
  print(nametag("Jane", "Smith"))
  print(nametag("Francesco", "Rinaldi"))
  print(nametag("Jean-Luc", "Grand-Pierre"))
  # output:
  # Jane S.
  # Francesco R.
  # Jean-Luc G.

  # Example
  # The replace_ending function replaces a specified substring at the end of a given sentence with a new substring. If the specified substring does not appear at the end of the given sentence, no action is performed and the original sentence is returned. If there is more than one occurrence of the specified substring in the sentence, only the substring at the end of the sentence is replaced. For example, replace_ending("abcabc", "abc", "xyz") should return abcxyz, not xyzxyz or xyzabc. The string comparison is case-sensitive, so replace_ending("abcabc", "ABC", "xyz") should return abcabc (no changes made). 
  def replace_ending(sentence, old, new):
    if sentence.endswith(old):
      i = len(old)
      new_sentence = sentence[:-i] + sentence[-i:].replace(old, new)
      return new_sentence
    return sentence
  print(replace_ending("It's raining cats and cats", "cats", "dogs"))
  print(replace_ending("She sells seashells by the seashore", "seashells", "donuts"))
  print(replace_ending("The weather is nice in May", "may", "april"))
  print(replace_ending("The weather is nice in May", "May", "April"))
  # output:
  # It's raining cats and dogs
  # She sells seashells by the seashore
  # The weather is nice in May
  
  # The weather is nice in April

  
